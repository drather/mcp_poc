# MCP PoC Todo-List (S1)

> RAG 시스템과 연동하여 외부 시스템(WEB/WAS/DB)과 실시간 상호작용을 검증하기 위한 PoC 계획

## Phase 1: 가상 시스템 환경 구축

- [x] **DB 정의 및 생성**
    - [x] 간단한 `tasks` 테이블 정의 (e.g., id, content, status, created_at)
    - [x] `mcp_poc/db/db.json` 또는 SQLite를 사용하여 초기 데이터 구성

- [x] **WAS (API 서버) 개발**
    - [x] Python FastAPI/Flask 등을 사용하여 API 서버 (`mcp_poc/was/app.py`) 구현
    - [x] DB의 `tasks` 테이블과 연동하는 CRUD API 엔드포인트 구현
        - `GET /api/tasks`: 모든 할 일 목록 조회
        - `POST /api/tasks`: 새 할 일 추가
        - `PUT /api/tasks/{task_id}`: 할 일 상태 업데이트
    - [x] API 명세 간단히 문서화

- [x] **WEB 서버 구성**
    - [x] Nginx (`mcp_poc/web/nginx.conf`) 설정
    - [x] WAS API를 호출하는 간단한 정적 HTML/JS 페이지 (선택 사항, API 테스트만으로도 충분)

- [x] **컨테이너 환경 구성**
    - [x] `docker-compose.yml` 파일에 WEB, WAS, DB 서비스 정의
    - [x] `docker-compose up` 명령어로 전체 가상 시스템 환경 실행 확인

## Phase 2: MCP(Model-Controller-Pipeline) 핵심 로직 개발

- [x] **LLM 라우터(Router) 설계**
    - [x] 사용자 질문의 의도를 파악하여 어떤 도구를 사용할지 결정하는 기능
        - 예: "문서 찾아줘" -> RAG, "할 일 등록해줘" -> WAS API
    - [x] PoC 단계에서는 키워드 기반의 간단한 라우터로 구현

- [x] **도구(Tools) 정의**
    - [x] **RAG 연동 도구**: 기존 `rag_poc`를 호출할 수 있는 함수/클래스 정의
    - [x] **WAS API 호출 도구**: Phase 1에서 개발한 WAS API를 호출하는 함수/클래스 정의

- [x] **MCP 파이프라인 구현**
    - [x] 사용자 질문 -> 라우터 -> 도구 선택 -> 도구 실행 -> 결과 반환의 흐름을 제어하는 메인 파이프라인 코드 작성
    - [x] 도구 실행 결과를 바탕으로 최종 답변을 생성하도록 LLM과 연동

## Phase 3: 통합 및 시나리오 검증

- [x] **RAG 시스템 API화**
    - [x] 기존 `rag_poc`를 외부(MCP)에서 호출할 수 있도록 간단한 API 형태로 래핑

- [x] **통합 테스트 시나리오 작성**
    - [x] **시나리오 1 (RAG):** "인프라 변경 이력에 대해 알려줘" -> RAG 도구 호출 확인
    - [x] **시나리오 2 (MCP):** "새로운 할 일 'API 명세 작성'을 추가해줘" -> WAS API 도구 호출 확인
    - [x] **시나리오 3 (복합):** "시스템 구성 문서를 참고해서 '웹서버 설정 검토' 할 일을 추가해줘" -> RAG로 문서 검색 후, 그 내용을 기반으로 WAS API 호출 확인 (심화)

- [x] **시나리오 기반 테스트 및 결과 검증**
    - [x] 각 시나리오별로 MCP가 의도대로 동작하는지 확인하고 결과 기록

## Phase 4: 문서화 및 정리

- [x] PoC 과정, 구현 내용, 테스트 결과 등을 간단히 문서로 정리
- [x] 향후 발전 방향 및 개선점 도출

---

## 향후 발전 방향 및 개선점

### 1. 라우터(Router) 지능화
- **LLM 기반 라우팅:** 현재 키워드 기반의 라우터를 LLM을 활용하는 방식으로 고도화할 수 있습니다. 사용자 질문과 사용 가능한 도구(RAG, WAS-API 등)의 설명을 LLM에 제공하여, LLM이 직접 어떤 도구를 어떤 순서로 사용할지 **실행 계획(Plan)**을 수립하게 만듭니다. 이를 통해 훨씬 더 복잡하고 미묘한 사용자 요청을 처리할 수 있습니다.

### 2. 도구(Tool) 기능 확장 및 정교화
- **WAS API 기능 확장:** 현재 '목록 조회', '추가'만 가능한 WAS API에 '수정(Update)', '삭제(Delete)', '상태 변경' 등의 기능을 추가하여 더 다양한 시스템 제어가 가능하도록 확장합니다.
- **LLM 기반 파라미터 추출:** "'내일 오후 3시에 회의' 할 일을 추가해줘"와 같은 자연어에서 `content: '회의'`, `due_date: '내일 오후 3시'`와 같은 정보를 LLM이 정확히 추출하여 API에 전달하는 'Function Calling' 또는 'Tool Use' 기능을 도입합니다. 현재의 단순 문자열 파싱 로직을 대체하여 정확도를 높입니다.

### 3. RAG 시스템 성능 개선
- **하이브리드 검색(Hybrid Search):** 현재의 벡터 기반 의미 검색에, 검색 정확도를 높이기 위해 전통적인 키워드 기반 검색(e.g., BM25)을 결합하는 하이브리드 검색을 도입합니다.
- **답변 품질 향상:** 검색된 문서들을 LLM에 전달하기 전에, 관련성이 높은 순서로 다시 정렬하는 'Re-ranking' 모델을 추가하여 최종 답변의 품질을 높일 수 있습니다.

### 4. 사용자 인터페이스(UI) 구축
- **채팅 인터페이스:** 현재 스크립트와 `curl`로 테스트하는 방식을 넘어, 실제 사용자들이 쉽게 사용할 수 있도록 Streamlit이나 간단한 웹 프론트엔드(HTML/JS)를 사용하여 채팅 형태의 UI를 구축합니다.

### 5. 비동기 처리 도입
- **긴 작업 처리:** RAG 검색 등 시간이 오래 걸릴 수 있는 작업을 처리할 때, 사용자가 계속 기다리지 않도록 비동기(Asynchronous) 방식으로 처리하는 아키텍처를 도입합니다. 사용자는 작업을 요청하고, 나중에 작업 상태를 확인하거나 완료 알림을 받을 수 있습니다.